{"version":3,"sources":["applyPanBoundariesToOffset.ts"],"names":["applyPanBoundariesToOffset","offsetScaled","containerSize","contentSize","scale","boundaryPadding","contentSizeUnscaled","offsetUnscaled","contentStartBorderUnscaled","contentEndBorderUnscaled","containerStartBorder","containerEndBorder","paddedContainerSize","paddedContainerStartBorder","paddedContainerEndBorder","contentMaxOffsetScaled"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,0BAAT,CACLC,YADK,EAELC,aAFK,EAGLC,WAHK,EAILC,KAJK,EAKLC,eALK,EAML;AACA,QAAMC,mBAAmB,GAAGH,WAAW,GAAGC,KAA1C;AACA,QAAMG,cAAc,GAAGN,YAAY,GAAGG,KAAtC;AAEA,QAAMI,0BAA0B,GAC9BN,aAAa,GAAG,CAAhB,GAAoBK,cAApB,GAAqCD,mBAAmB,GAAG,CAD7D;AAEA,QAAMG,wBAAwB,GAC5BD,0BAA0B,GAAGF,mBAD/B;AAGA,QAAMI,oBAAoB,GAAG,CAA7B;AACA,QAAMC,kBAAkB,GAAGD,oBAAoB,GAAGR,aAAlD,CAVA,CAYA;;AACA,MAAI,CAACG,eAAD,IAAoBA,eAAe,GAAG,CAA1C,EAA6CA,eAAe,GAAG,CAAlB;AAC7C,MAAIA,eAAe,GAAGH,aAAtB,EAAqCG,eAAe,GAAGH,aAAlB,CAdrC,CAgBA;AACA;AACA;;AACA,QAAMU,mBAAmB,GAAGV,aAAa,GAAGG,eAAe,GAAG,CAA9D;AACA,QAAMQ,0BAA0B,GAAGH,oBAAoB,GAAGL,eAA1D;AACA,QAAMS,wBAAwB,GAAGH,kBAAkB,GAAGN,eAAtD,CArBA,CAuBA;AACA;;AACA,MAAIC,mBAAmB,GAAGM,mBAA1B,EAA+C;AAC7C,WAAO,CAAP;AACD,GA3BD,CA6BA;AACA;AAEA;AACA;;;AACA,QAAMG,sBAAsB,GAC1B,CAACH,mBAAmB,GAAG,CAAtB,GAA0BN,mBAAmB,GAAG,CAAjD,IAAsDF,KADxD;;AAGA,OACE;AACAK,EAAAA,wBAAwB,GAAGK,wBAF7B,EAGE;AACA,WAAOC,sBAAP;AACD;;AACD,OACE;AACAP,EAAAA,0BAA0B,GAAGK,0BAF/B,EAGE;AACA,WAAO,CAACE,sBAAR;AACD;;AAED,SAAOd,YAAP;AACD","sourcesContent":["/**\n * Takes a single offset value and calculates the correct offset value\n * to make sure it's within the pan boundaries\n *\n *\n * @param offsetScaled\n * @param containerSize\n * @param contentSize\n * @param scale\n * @param boundaryPadding - see README\n *\n * @returns {number}\n */\nexport function applyPanBoundariesToOffset(\n  offsetScaled: number,\n  containerSize: number,\n  contentSize: number,\n  scale: number,\n  boundaryPadding: number\n) {\n  const contentSizeUnscaled = contentSize * scale;\n  const offsetUnscaled = offsetScaled * scale;\n\n  const contentStartBorderUnscaled =\n    containerSize / 2 + offsetUnscaled - contentSizeUnscaled / 2;\n  const contentEndBorderUnscaled =\n    contentStartBorderUnscaled + contentSizeUnscaled;\n\n  const containerStartBorder = 0;\n  const containerEndBorder = containerStartBorder + containerSize;\n\n  // do not let boundary padding be greater than the container size or less than 0\n  if (!boundaryPadding || boundaryPadding < 0) boundaryPadding = 0;\n  if (boundaryPadding > containerSize) boundaryPadding = containerSize;\n\n  // Calculate container's measurements with boundary padding applied.\n  // this should shrink the container's size by the amount of the boundary padding,\n  // so that the content inside can be panned a bit further away from the original container's boundaries.\n  const paddedContainerSize = containerSize - boundaryPadding * 2;\n  const paddedContainerStartBorder = containerStartBorder + boundaryPadding;\n  const paddedContainerEndBorder = containerEndBorder - boundaryPadding;\n\n  // if content is smaller than the padded container,\n  // don't let the content move\n  if (contentSizeUnscaled < paddedContainerSize) {\n    return 0;\n  }\n\n  // if content is larger than the padded container,\n  // don't let the padded container go outside of content\n\n  // maximum distance the content's center can move from its original position.\n  // assuming the content original center is the container's center.\n  const contentMaxOffsetScaled =\n    (paddedContainerSize / 2 - contentSizeUnscaled / 2) / scale;\n\n  if (\n    // content reaching the end boundary\n    contentEndBorderUnscaled < paddedContainerEndBorder\n  ) {\n    return contentMaxOffsetScaled;\n  }\n  if (\n    // content reaching the start boundary\n    contentStartBorderUnscaled > paddedContainerStartBorder\n  ) {\n    return -contentMaxOffsetScaled;\n  }\n\n  return offsetScaled;\n}\n"]}